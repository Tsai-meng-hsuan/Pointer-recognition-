# -*- coding: utf-8 -*-
"""test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x-ihWUXDd_fb8CYCyG1Va_b761sfBlmx
"""

import cv2
import numpy as np
import math
import glob


def identify_gauge(file_name):
    img = cv2.imread(file_name)
    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # cv2.imshow("img",img_gray)
    # cv2.waitKey()
    
    #二值化
    ret, output1 = cv2.threshold(img_gray, 127, 255, cv2.THRESH_BINARY)
    
    #邊緣檢測
    dst_img = cv2.Canny(output1, 50, 200, None, 3)
    
    #霍夫圓檢測
    circles = cv2.HoughCircles(dst_img,cv2.HOUGH_GRADIENT,1,500,param1=70,param2=30,minRadius=200,maxRadius=0)
    circles = np.uint16(np.around(circles))
    
    #劃出圓與圓心
    for i in circles[0,:]:
        # draw the outer circle
        cv2.circle(img,(i[0],i[1]),i[2],(0,255,0),2)
        # draw the center of the circle
        cv2.circle(img,(i[0],i[1]),2,(255,0,0),3)
        cv2.line(img,(i[0]-100,i[1]),(i[0]+100,i[1]),(255,0,0),2)
        cv2.line(img,(i[0],i[1]-100),(i[0],i[1]+100),(255,0,0),2)
    
    #     # draw the outer circle
    #     cv2.circle(drew_img,(i[0],i[1]),i[2],(0,255,0),2)
    #     # draw the center of the circle
    #     cv2.circle(drew_img,(i[0],i[1]),2,(255,0,0),3)
    #     cv2.line(drew_gimg,(i[0],i[1]-100),(i[0],i[1]+100),(255,0,0),2)
    #     cv2.line(drew_gimg,(i[0],i[1]-100),(i[0],i[1]+100),(255,0,0),2)
    
    # cv2.imshow("img",drew_gimg)
    # cv2.waitKey()
    
    # print("圓心座標: ",(i[0],i[1]))
    
    # 使用 np.full 创建一个480x640的3通道矩阵，并且用255的值填充整个矩阵，
    #讀取圖片形狀
    img_Y = img.shape[0]
    img_X = img.shape[1]
    
    #生成圖片遮罩
    # 建立掩膜
    center = circles[0,:]
    center_X = center[0][0]
    center_Y = center[0][1]
    center_R = center[0][2]
    window = np.zeros((img_Y, img_X,3), dtype='uint8')
    window = cv2.circle(window, (center_X, center_Y), center_R, (255, 255, 255), -1)
    # cv2.imshow("img",window)
    # cv2.waitKey()
    
    # window = np.zeros((img_Y, img_X,3), dtype='uint8')       # 產生一張 480x360 背景全黑的圖
    # window[0:img_Y, 0:img_X] = '255'                        # 將圖片變成白色 ( 配合 logo 是白色底 )
    # center = circles[0,:]
    # center_X = center[0][0]
    # center_Y = center[0][1]
    # center_R = center[0][2]
    
    # #選取霍夫圓區間內
    # for x in range(img_X):
    #     for y in range(img_Y):
    #         delta_X = abs(center_X - x)
    #         delta_Y = abs(center_Y - y)
    #         delta_R = (delta_X**2 + delta_Y**2)**0.5
    #         if delta_R < center_R:
    #             window[y, x] = 1
    
    #遮罩合成
    window_gray = cv2.cvtColor(window, cv2.COLOR_BGR2GRAY) # 產生一張灰階的圖片作為遮罩使用
    ret, mask1  = cv2.threshold(window_gray, 200, 255, cv2.THRESH_BINARY)  # 使用二值化的方法，產生黑白遮罩圖片
    # cv2.imshow("img",window_gray)
    # cv2.waitKey()
    only_circle = cv2.bitwise_and(dst_img, dst_img, mask = mask1)
    # cv2.imshow("img",only_circle)
    # cv2.waitKey()
    
    #遮罩內邊緣檢測
    # dst_img = cv2.Canny(only_circle, 50, 200, None, 3)
    dst_img = only_circle
    # n = 2
    # before_lines = cv2.HoughLines(dst_img, n, np.pi/180, 150, None, 0, 0)
    
    # #找唯一霍夫線檢測
    # while True:
    #     before_lines = before_lines
    #     n = n - 0.01
    #     after_lines = cv2.HoughLines(dst_img, n, np.pi/180, 150, None, 0, 0)
    #     try:
    #         print("len of lines: ",len(after_lines))
    #         if len(after_lines) == 1:
    #             print("get only one solution")
    #             before_lines = after_lines
    #             print("n: ",n)
    #             break
    #     except:
    #         print("len = 0")
    #         break
    
    # try:
    #     for i in range(0, len(before_lines)):
    #         rho_l = before_lines[i][0][0] #距離
    #         theta_l = before_lines[i][0][1] #角度
    #         a_l = math.cos(theta_l)
    #         b_l = math.sin(theta_l)
    #         x0_l = a_l * rho_l
    #         y0_l = b_l * rho_l
    #         pt1_l = (int(x0_l + 500 * (-b_l)), int(y0_l + 500 * (a_l)))
    #         pt2_l = (int(x0_l - 500 * (-b_l)), int(y0_l - 500 * (a_l)))
    #         cv2.line(img, pt1_l, pt2_l, (0, 0, 255), 1, cv2.LINE_AA)
    # except:
    #     None
    
    # cv2_imshow(img)
    # cv2_imshow(dst_img)
    
    #找機率霍夫線
    n = 2
    min_L = 100
    before_Plines = cv2.HoughLinesP(dst_img,n,np.pi/180,100,minLineLength = min_L, maxLineGap=10)
    while True:
        print(min_L)
        try:
            if min_L <= 0:
                print("error")
                break
            if len(before_Plines) < 2:
                min_L = min_L - 5
                after_Plines = cv2.HoughLinesP(dst_img, n, np.pi/180, 100, minLineLength = min_L, maxLineGap=10)
                before_Plines = after_Plines
    
            else:
                # print("min_L: ",min_L)
                # print("find lines:", len(before_Plines))
                break
        except:
            min_L = min_L - 5
    
    #劃出機率霍夫線
    # Pimg = img
    # for line in before_Plines:
    #     x1,y1,x2,y2 = line[0]
    #     cv2.line(Pimg,(x1,y1),(x2,y2),(0,0,255),2)
    
    #計算機率霍夫線長度
    # print(before_Plines[1])
    line_L_list = []
    for i in range(len(before_Plines)):
        line_X = abs(before_Plines[i][0][0]-before_Plines[i][0][2])
        line_Y = abs(before_Plines[i][0][1]-before_Plines[i][0][3])
        line_L = (line_X**2+line_Y**2)**0.5
        line_L_list.append(line_L)
    
    # print(line_L_list)
    
    #選出機率霍夫線最大長度者位置
    longest_line = line_L_list.index(max(line_L_list))
    # print(before_Plines[longest_line][0][0])
    # print("Longest line:",longest_line)
    
    #選出離圓心最遠點
    center_X = center[0][0]
    center_Y = center[0][1]
    point1 = [before_Plines[longest_line][0][0], before_Plines[longest_line][0][1]]
    point2 = [before_Plines[longest_line][0][2], before_Plines[longest_line][0][3]]
    
    PX1 = abs(point1[0]-center_X)
    PY1 = abs(point1[1]-center_Y)
    RP1 = (PX1**2+PY1**2)**0.5
    
    PX2 = abs(point2[0]-center_X)
    PY2 = abs(point2[1]-center_Y)
    RP2 = (PX2**2+PY2**2)**0.5
    
    
    if RP1 >= RP2:
        choose_X = point1[0]
        choose_Y = point1[1]
      
    else:
        choose_X = point2[0]
        choose_Y = point2[1]
    
    cv2.line(img,(center_X,center_Y),(choose_X,choose_Y),(0,0,255),2)
    #座標轉換
    new_X = choose_X - center_X
    new_Y = -(choose_Y - center_Y)
    tan = new_Y/new_X
    angel = math.atan(tan)*180/3.1415926
    #象限判斷
    
    if new_X > 0:
        if new_Y > 0:
            print('第一象限')
            angel = angel
        else:
            print('第四象限')
            angel = 360 + angel
    else:
        if new_Y > 0:
            print('第二象限')
        else:
            print('第三象限')
        angel = angel+180
    
    print("angel: ",angel)
    
    cv2.imshow("img",img)
    cv2.waitKey()
    return(angel)

filename = glob.glob(r'picture/*.png')
angel_list = []
aa = 0
for i in filename:
    try:
        angel_list.append(identify_gauge(i))
        aa = aa+1
    except:
        print("error: " + i)
        angel_list.append('None')